{{- if .Values.otelValidationJob.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: duplo-otel-validation
  namespace: {{ .Release.Namespace }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": hook-succeeded,before-hook-creation
spec:
  backoffLimit: 0
  template:
    spec:
      containers:
        - name: otel-validation
          image: "{{ .Values.otelValidationJob.image }}:{{ .Values.otelValidationJob.imageTag }}"
          command:
            - /bin/sh
            - '-c'
            - |
              set -euo pipefail
              STATUS_LINES=""
              ANY_FAIL=0
              TIME_RANGE="5m"
              CLUSTER="${CLUSTER_NAME:-unknown}"

              # --- Helper Functions ---

              get_ds_id() {
                local uid="$1"; local name="$2"
                local resp
                resp="$(curl -fsS -u "${GRAFANA_USER}:${GRAFANA_PASS}" "${GRAFANA_URL}/api/datasources/uid/${uid}")" || {
                  STATUS_LINES="$STATUS_LINES\n‚ùå ${name}: could not read datasource UID ${uid}"
                  ANY_FAIL=1
                  return 1
                }
                id_val="$(echo "$resp" | sed -n 's/.*"id":[ ]*\([0-9][0-9]*\).*/\1/p' | head -n1)"
                if [ -z "$id_val" ]; then
                  STATUS_LINES="$STATUS_LINES\n‚ùå ${name}: datasource UID ${uid} missing id"
                  ANY_FAIL=1
                  return 1
                fi
                echo "$id_val"
              }

              add_status() {
                local ok="$1"; shift
                local msg="$*"
                # Log each check as it is evaluated for pre-deploy visibility
                echo "CHECK: $msg (ok=$ok)"
                if [ "$ok" -eq 0 ]; then
                  STATUS_LINES="$STATUS_LINES\n‚úÖ $msg"
                else
                  STATUS_LINES="$STATUS_LINES\n‚ùå $msg"
                  ANY_FAIL=1
                fi
              }

              # --- Main Execution ---

              echo "=== OTEL FULLSTACK Grafana Validation ==="

              # Wait for other hook jobs to finish before validation
              echo "üîé Waiting for Jobs in {{ .Release.Namespace }} namespace..."
              while true; do
                incomplete=$(kubectl get jobs -n {{ .Release.Namespace }} --no-headers \
                  | grep -v "duplo-otel-validation" | awk '{print $1 " " $3}' | grep -v "1/1" || true)
                if [ -z "$incomplete" ]; then
                  echo "‚úÖ All dependent jobs completed."
                  STATUS_LINES="$STATUS_LINES\n‚úÖ All dependent jobs completed"
                  break
                else
                  echo "‚è≥ Still waiting: $incomplete"
                  sleep 10
                fi
              done

              # Resolve datasource IDs
              echo "Resolving Grafana datasource IDs..."
              LOKI_DS_ID="$(get_ds_id "${LOKI_DS_UID}" "Loki")" || true
              MIMIR_DS_ID="$(get_ds_id "${MIMIR_DS_UID}" "Mimir")" || true
              TEMPO_DS_ID="$(get_ds_id "${TEMPO_DS_UID}" "Tempo")" || true
              PYRO_DS_ID="$(get_ds_id "${PYRO_DS_UID}" "Pyroscope")" || true

              END_S=$(date +%s)
              START_S=$((END_S-300))
              END_NS=$((END_S*1000000000))     # epoch seconds -> ns
              START_NS=$((START_S*1000000000)) # last 5m in ns
              END_MS=$((END_S*1000))           # epoch seconds -> ms
              START_MS=$((START_S*1000))        # last 5m in ms

              # Loki logs
              if [ -n "$LOKI_DS_ID" ]; then
                set +e
                loki_resp="$(curl -sS -w '\nHTTP_STATUS:%{http_code}' -u "${GRAFANA_USER}:${GRAFANA_PASS}" -G \
                  --data-urlencode "query={cluster=\"$CLUSTER\"}" \
                  --data-urlencode "start=${START_NS}" \
                  --data-urlencode "end=${END_NS}" \
                  --data-urlencode "direction=backward" \
                  --data-urlencode "limit=1" \
                  "${GRAFANA_URL}/api/datasources/proxy/uid/${LOKI_DS_UID}/loki/api/v1/query_range" )"
                loki_rc=$?
                set -e
                loki_body="$(echo "$loki_resp" | sed '$d')"
                loki_status="$(echo "$loki_resp" | tail -n1 | sed 's/HTTP_STATUS://')"
                if [ $loki_rc -eq 0 ] && [ "$loki_status" -ge 400 ]; then loki_rc=1; fi
                if [ $loki_rc -eq 0 ] && echo "$loki_body" | grep -q '"result":\[\]' ; then loki_rc=1; fi
                if [ $loki_rc -ne 0 ]; then
                  echo "DEBUG Loki status=$loki_status body=$(echo "$loki_body" | head -c 400)"
                fi
                add_status $loki_rc "Loki logs present for cluster=${CLUSTER}"
              else
                add_status 1 "Loki datasource not resolved"
              fi

              # Mimir metrics
              if [ -n "$MIMIR_DS_ID" ]; then
                set +e
                mimir_resp="$(curl -sS -w '\nHTTP_STATUS:%{http_code}' -u "${GRAFANA_USER}:${GRAFANA_PASS}" -G \
                  --data-urlencode "query=sum by (cluster) (kube_pod_info{cluster=\"$CLUSTER\"})" \
                  --data-urlencode "time=${END_S}" \
                  "${GRAFANA_URL}/api/datasources/proxy/uid/${MIMIR_DS_UID}/api/v1/query" )"
                mimir_rc=$?
                set -e
                mimir_body="$(echo "$mimir_resp" | sed '$d')"
                mimir_status="$(echo "$mimir_resp" | tail -n1 | sed 's/HTTP_STATUS://')"
                if [ $mimir_rc -eq 0 ] && [ "$mimir_status" -ge 400 ]; then mimir_rc=1; fi
                if [ $mimir_rc -eq 0 ] && echo "$mimir_body" | grep -q '"result":\[\]'; then mimir_rc=1; fi
                if [ $mimir_rc -ne 0 ]; then
                  echo "DEBUG Mimir status=$mimir_status body=$(echo "$mimir_body" | head -c 400)"
                fi
                add_status $mimir_rc "Mimir metrics present for cluster=${CLUSTER}"
              else
                add_status 1 "Mimir datasource not resolved"
              fi

              # Tempo traces
              if [ -n "$TEMPO_DS_ID" ]; then
                set +e
                tempo_resp="$(curl -sS -w '\nHTTP_STATUS:%{http_code}' -u "${GRAFANA_USER}:${GRAFANA_PASS}" -G \
                  --data-urlencode "query=resource.k8s.cluster.name=\"$CLUSTER\"" \
                  --data-urlencode "limit=1" \
                  --data-urlencode "start=${START_MS}" \
                  --data-urlencode "end=${END_MS}" \
                  "${GRAFANA_URL}/api/datasources/proxy/uid/${TEMPO_DS_UID}/api/search" )"
                tempo_rc=$?
                set -e
                tempo_body="$(echo "$tempo_resp" | sed '$d')"
                tempo_status="$(echo "$tempo_resp" | tail -n1 | sed 's/HTTP_STATUS://')"
                if [ $tempo_rc -eq 0 ] && [ "$tempo_status" -ge 400 ]; then tempo_rc=1; fi
                if [ $tempo_rc -eq 0 ] && echo "$tempo_body" | grep -q '"traces":[[]'; then tempo_rc=1; fi
                if [ $tempo_rc -ne 0 ]; then
                  echo "DEBUG Tempo status=$tempo_status body=$(echo "$tempo_body" | head -c 400)"
                fi
                add_status $tempo_rc "Tempo traces present for cluster=${CLUSTER}"
              else
                add_status 1 "Tempo datasource not resolved"
              fi

              # Pyroscope CPU profiles
              if [ -n "$PYRO_DS_ID" ]; then
                set +e
                pyro_resp="$(curl -sS -w '\nHTTP_STATUS:%{http_code}' -u "${GRAFANA_USER}:${GRAFANA_PASS}" -G \
                  --data-urlencode "query=scope:cpu:cpu:nanoseconds:sum{cluster=\"$CLUSTER\"}" \
                  --data-urlencode "from=${START_S}" \
                  --data-urlencode "until=${END_S}" \
                  "${GRAFANA_URL}/api/datasources/proxy/uid/${PYRO_DS_UID}/render" )"
                pyro_rc=$?
                set -e
                pyro_body="$(echo "$pyro_resp" | sed '$d')"
                pyro_status="$(echo "$pyro_resp" | tail -n1 | sed 's/HTTP_STATUS://')"
                if [ $pyro_rc -eq 0 ] && [ "$pyro_status" -ge 400 ]; then pyro_rc=1; fi
                if [ $pyro_rc -eq 0 ] && echo "$pyro_body" | grep -q '"values":\[\]'; then pyro_rc=1; fi
                if [ $pyro_rc -ne 0 ]; then
                  echo "DEBUG Pyroscope status=$pyro_status body=$(echo "$pyro_body" | head -c 400)"
                fi
                add_status $pyro_rc "Pyroscope CPU profiles present for cluster=${CLUSTER}"
              else
                add_status 1 "Pyroscope datasource not resolved"
              fi

              ##############################################
              # Final Report
              ##############################################
              echo -e "\n=== Validation Summary ==="
              echo -e "$STATUS_LINES"
              echo "=========================="

              if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
                payload="$(printf '{"text":"OTEL Validation for cluster %s\n%s"}' "$CLUSTER" "$(echo -e "$STATUS_LINES" | sed 's/"/\\"/g')" )"
                curl -fsS -X POST -H "Content-Type: application/json" -d "$payload" "$SLACK_WEBHOOK_URL" || true
              fi

              if [ "$ANY_FAIL" -eq 1 ]; then
                echo "‚ùå Validation FAILED."
                exit 1
              else
                echo "‚úÖ Validation SUCCESS."
                exit 0
              fi
          env:
          - name: SLACK_WEBHOOK_URL
            value: {{ .Values.global.slackWebhookUrl }}
          - name: CLUSTER_NAME
            value: {{ .Values.global.clusterName }}
          - name: LOKI_DS_UID
            value: "duplo-logging"
          - name: MIMIR_DS_UID
            value: "duplo-metrics"
          - name: TEMPO_DS_UID
            value: "duplo-tracing"
          - name: PYRO_DS_UID
            value: "duplo-profiling"
          - name: GRAFANA_USER
            valueFrom:
              secretKeyRef:
                name: grafanaui
                key: username
          - name: GRAFANA_PASS
            valueFrom:
              secretKeyRef:
                name: grafanaui
                key: password
          # Service endpoints ‚Äî set these to your actual service names if different
          - name: GRAFANA_URL
            value: "http://grafana-ui:3000"
          - name: DUPLO_AUTOMATION
            value: "http://duplo-automation:5000"
          - name: STRICT_FAIL
            value: "true"
      serviceAccountName: {{ .Release.Namespace }}-edit-user
      restartPolicy: Never
{{- if .Values.pdc.nodeSelector }}
      nodeSelector:
{{ toYaml .Values.pdc.nodeSelector | indent 8 }}
{{- end }}
---
{{- end }}